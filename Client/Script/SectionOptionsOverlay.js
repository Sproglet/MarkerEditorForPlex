import { $, appendChildren, buildNode, errorResponseOverlay, ServerCommand } from './Common.js';
import { Log } from '../../Shared/ConsoleLog.js';

import Animation from './inc/Animate.js';
import Overlay from './inc/Overlay.js';
import ThemeColors from './ThemeColors.js';

import ButtonCreator from './ButtonCreator.js';
import { MarkerEnum } from '../../Shared/PlexTypes.js';
import { PlexClientState } from './PlexClientState.js';

/** @typedef {import('./inc/Overlay').OverlayOptions} OverlayOptions */

class SectionOptionsOverlay {
    #focusBack;
    constructor() { }

    show(target) {
        this.#focusBack = target;
        const container = buildNode('div', { class : 'sectionOptionsOverlayContainer' });
        appendChildren(container,
            buildNode('h1', {}, 'Section Options'),
            buildNode('hr'),
            ButtonCreator.textButton('Import/Export markers', this.#onImportExport.bind(this), { class : 'sectionOptionsOverlayBtn' }),
            ButtonCreator.textButton(
                'Delete all markers',
                this.#onDeleteAll.bind(this),
                { class : 'sectionOptionsOverlayBtn cancelSetting' }));

        Overlay.build({ dismissible : true, focusBack : this.#focusBack, noborder : true, closeButton : true }, container);
    }

    #onImportExport() {
        Log.info('Import/export!');
        Overlay.dismiss();
        setTimeout(() => { Overlay.show('Not Yet Implemented'); Overlay.setFocusBackElement(this.#focusBack); }, 250);
    }

    /**
     * Show an overlay making it as clear as possible that deleting section markers is not reversible. */
    #onDeleteAll() {
        const warnIntro = 'Are you sure you want to delete all markers in this section?<br><br>This will ' +
        'remove all markers from the Plex database (both customized and autogenerated), in addition to removing ' +
        'all references to this section in the backup database.<br><br><i>THIS CANNOT BE UNDONE</i>.<br><br>';
        const warnText = buildNode('div', { id : 'confirmDeleteAllContainer' }, warnIntro);

        const okayAttr = { id : 'overlayDeleteMarker', class : 'overlayButton confirmDelete' };
        const okayButton = ButtonCreator.textButton('Delete', this.#deleteAllConfirmed.bind(this), okayAttr);

        const cancelAttr = { id : 'deleteMarkerCancel', class : 'overlayButton' };
        const cancelButton = ButtonCreator.textButton('Cancel', Overlay.dismiss, cancelAttr);

        warnText.appendChild(
            buildNode('span', {}, `If you're sure you want to continue, type DELETE (all caps) ` +
                `into the box below, and then click 'Delete'.`));

        appendChildren(warnText,
            buildNode('br'), buildNode('br'),
            buildNode('label', { for : 'confirmDeleteAllText' }, 'Type DELETE: '),
            buildNode('input', { type : 'text', id : 'confirmDeleteAllText' }),
            buildNode('br'),
            buildNode('label', { for : 'deleteAllTypeSelect' }, 'Delete'),
            appendChildren(buildNode('select', { id : 'deleteAllTypeSelect' }),
                buildNode('option', { value : MarkerEnum.Credits | MarkerEnum.Intro }, 'intro and credit markers'),
                buildNode('option', { value : MarkerEnum.Intro }, 'intro markers'),
                buildNode('option', { value : MarkerEnum.Credits }, 'credit markers')),
            buildNode('br'),
            okayButton,
            cancelButton);

        const container = buildNode('div', { class : 'sectionOptionsOverlayContainer' });
        appendChildren(container,
            buildNode('h2', {}, 'DANGER ZONE'),
            buildNode('hr'),
            warnText);
        this.#transitionOverlay(
            container,
            { dismissible : true, centered : true, focusBack : this.#focusBack });
    }

    /**
     * Verify the user actually wants to delete markers, and try to do it. */
    async #deleteAllConfirmed() {
        const text = $('#confirmDeleteAllText').value;
        if (text !== 'DELETE') {
            this.#flashInput($('#confirmDeleteAllText'));
            return;
        }

        Log.warn(`Attempting to delete markers for an entire section.`);
        const deleteType = parseInt($('#deleteAllTypeSelect').value);
        try {
            const result = await ServerCommand.sectionDelete(PlexClientState.activeSection(), deleteType);
            Overlay.dismiss(true /*forReshow*/);
            setTimeout(() => {
                Overlay.show(
                    `<h2>Section Delete Succeeded</h2><hr>` +
                        `Markers Deleted: ${result.deleted}<br>` +
                        `Backup Entries Removed: ${result.backupDeleted}<br>`,
                    'Reload',
                    // Easier to just reload the page instead of reconciling all the newly deleted markers
                    () => { window.location.reload(); },
                    false /*dismissible*/);
                Overlay.setFocusBackElement(this.#focusBack);
            }, 250);
        } catch (err) {
            errorResponseOverlay('Failed to delete section markers.', err);
        }
    }

    /**
     * Dismiss the current overlay and immediately replace it with a new one.
     * @param {HTMLElement} container
     * @param {OverlayOptions} options */
    #transitionOverlay(container, options) {
        Overlay.dismiss(true /*forReshow*/);
        setTimeout(() => { Overlay.build(options, container); }, 250);
    }

    /**
     * Flash the background of the given element.
     * @param {HTMLElement} input */
    #flashInput(input) {
        Animation.queue({ backgroundColor : `#${ThemeColors.get('red')}8` }, input, 500);
        return new Promise((resolve, _) => {
            Animation.queueDelayed({ backgroundColor : 'transparent' }, input, 500, 500, true, resolve);
        });
    }
}

export default SectionOptionsOverlay;
