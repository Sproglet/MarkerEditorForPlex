const FS = require('fs');
const Path = require('path');
const Log = require('./inc/script/ConsoleLog');

/// <summary>
/// The ThumbnailManager class reads thumbnail preview files generated by Plex and
/// 
/// </summary>
class ThumbnailManager {
    /// <summary>Maximum number of thumbnails to keep cached</summary>
    static #maxCache = 100;

    /// <summary>
    /// Database query to retrieve the media hash for an episode,
    /// used for finding the path to the generated index-sd.bif files.
    /// </summary>
    static #hashQuery = `
        SELECT media_parts.id, media_parts.hash AS hash FROM media_parts
        INNER JOIN media_items ON media_parts.media_item_id=media_items.id
        INNER JOIN metadata_items ON media_items.metadata_item_id=metadata_items.id
        WHERE metadata_items.id=?
        ORDER BY media_parts.id ASC;`;

    constructor(db, metadataPath) {

        this.database = db;
        this.metadataPath = metadataPath;

        // Map of metadataIds to EpisodeCaches
        this.cache = {};
    }

    /// <summary>
    /// Return whether the given item has thumbnail previews
    /// </summary>
    async hasThumbnails(metadataId) {
        if (this.cache[metadataId]) {
            return Promise.resolve(this.cache[metadataId].hasThumbs);
        }

        return new Promise((resolve, reject) => {
            this.database.all(ThumbnailManager.#hashQuery, [metadataId], (err, rows) => {
                if (err) {
                    reject('Unable to retrieve media parts');
                }

                for (const row of rows) {
                    const bifPath = Path.join(this.metadataPath, 'Media', 'localhost', row.hash[0], row.hash.substring(1) + '.bundle', 'Contents', 'Indexes', 'index-sd.bif');
                    if (FS.existsSync(bifPath)) {
                        this.cache[metadataId] = new EpisodeCache(true, bifPath);
                        resolve(true);
                        return;
                    }
                }

                this.cache[metadataId] = new EpisodeCache(false);
                resolve(false);
            });
        });
    }

    /// <summary>
    /// Retrieve a thumbnail for the given episode at the given timestamp.
    /// Returns a promise that resolves if the thumbnail is found, and rejected if
    /// the thumbnail doesn't exist or we were otherwise unable to retrieve it.
    /// </summary>
    async getThumbnail(metadataId, timestamp) {
        if (!this.cache[metadataId]) {
            return this.hasThumbnails(metadataId).then(_ => {
                return this.#getThumbnailCore(metadataId, timestamp);
            });
        } else {
            return this.#getThumbnailCore(metadataId, timestamp);
        }
    }

    /// <summary>
    /// Checks the cache for the requested thumbnail and returns that if available.
    /// Otherwise kicks off the process of reading the bif file.
    ///
    /// Assumes hasThumbnails has been called for the given metadataId.
    /// </summary>
    async #getThumbnailCore(metadataId, timestamp) {
        if (!this.cache[metadataId] || !this.cache[metadataId].hasThumbs) {
            return Promise.reject('No thumbnails');
        }

        let thumbCache = this.cache[metadataId];
        let index;
        if (thumbCache.interval != 0) {
            index = Math.floor(timestamp / thumbCache.interval);
            if (thumbCache.cachedThumbnails[index]) {
                thumbCache.cachedThumbnails[index].rank = ThumbnailManager.#maxCache + 1;
                this.#touchCache();
                return Promise.resolve(thumbCache.cachedThumbnails[index].data);
            }
        }

        return this.#readThumbnail(metadataId, timestamp);
    }

    /// <summary>
    /// Open the index-sd.bif file and pick out the right thumbnail.
    /// </summary>
    async #readThumbnail(metadataId, timestamp) {
        let thumbCache = this.cache[metadataId];
        return new Promise((resolve, reject) => {

            // File layout:
            // Starts with magic 89 42 49 46 0D 0A 1A 0A (0x89 BIF \r\n\sub\n)
            // 32(?)-bit integer at offset 0xC indicating the number of thumbnails in the file
            // Index table starts at 0x40, with 8-byte records:
            //   * A 32-bit little-endian integer timestamp (in seconds) -> 02 00 00 00 -> 2 seconds
            //   * A 32-bit little-endian integer offset into the file indicating the start of the thumbnail.
            FS.readFile(thumbCache.bifPath, (err, data) => {
                if (err) {
                    reject('Failed to read thumbnail file');
                    return;
                }

                const thumbnailCountOffset = 0xC;
                const indexTableStart = 0x40;
                const recordSize = 0x8;
                const timestampSize = 0x4;
                const getOffset = (index) => data.readInt32LE(indexTableStart + (index * recordSize) + timestampSize);
                const getTimestamp = (index) => data.readInt32LE(indexTableStart + (index * recordSize));

                if (thumbCache.interval == 0) {
                    const verify = getTimestamp(0);
                    if (verify != 0) {
                        reject('Unexpected thumbnail file contents');
                        return;
                    }

                    thumbCache.interval = getTimestamp(1);
                }
    
                let index = Math.floor(timestamp / thumbCache.interval);
                
                // Last index points to the end of the file, so the real max is the
                // number of indexes minus 1.
                const maxIndex = data.readInt32LE(thumbnailCountOffset) - 1;
                if (index > maxIndex) {
                    Log.warn('Received thumbnail request beyond max timestamp. Retrieving last thumbnail instead.');
                    index = maxIndex;
                }
    
                const thumbStart = getOffset(index);
                const thumbEnd = index == maxIndex ? data.length : getOffset(index + 1);
                const thumbBuf = Buffer.alloc(thumbEnd - thumbStart);
                data.copy(thumbBuf, 0, thumbStart, thumbEnd);
                thumbCache.cachedThumbnails[index] = new CachedThumbnail(thumbBuf, ThumbnailManager.#maxCache + 1);
                this.#touchCache();
                resolve(thumbBuf);
            });
        });
    }

    /// <summary>
    /// Updates our LRU cache, removing items that haven't been retrieved in the last #maxCache requests.
    /// </summary>
    #touchCache() {
        for (const cacheItem of Object.values(this.cache)) {
            for (const index of Object.keys(cacheItem.cachedThumbnails)) {
                if (--cacheItem.cachedThumbnails[index].rank == 0) {
                    delete cacheItem.cachedThumbnails[index];
                }
            }
        }
    }
}

/// <summary>
/// Holds information about the index-sd.bif file for an episode, including any cached thumbnails.
/// </summary>
class EpisodeCache {
    constructor(hasThumbs, bifPath='') {
        this.hasThumbs = hasThumbs;
        this.bifPath = bifPath;
        this.cachedThumbnails = {};
        this.interval = 0;
    }
}

/// <summary>
/// A cached thumbnail, along with its rank (to be used by cache pruning)
/// </summary>
class CachedThumbnail {
    constructor(buffer, rank) {
        this.data = buffer;
        this.rank = rank;
    }
}


module.exports = {
    ThumbnailManager : ThumbnailManager
};
