import { existsSync, readFile } from 'fs';
import { join as joinPath } from 'path';

import { ConsoleLog } from '../Shared/ConsoleLog.js';

/** @typedef {!import('./CreateDatabase.cjs').SqliteDatabase} SqliteDatabase */
/** @typedef {{[metadataId: number]: EpisodeCache}} EpisodeCacheMap */

/**
 * The ThumbnailManager class reads thumbnail preview files generated by Plex to
 * pull out individual thumbnails from specific timestamps.
 *
 * A caching mechanism is also built in so that reused thumbnails don't always
 * need to be re-read from disk.
 */
class ThumbnailManager {
    /** Maximum number of thumbnails to keep cached */
    static #maxCache = 100;

    /** The Plex database connection.
     * @type {SqliteDatabase} */
    #database;

    /** The path the Plex's data directory.
     * @type {string} */
    #metadataPath;

    /** The logging instance for the app.
     * @type {ConsoleLog} */
    #log;

    /** A map of episode metadataIds to the cached thumbnails of the episode.
     * @type {EpisodeCacheMap} */
    #cache = {};

    /**
     * Database query to retrieve the media hash for an episode,
     * used for finding the path to the generated index-sd.bif files.
    */
    static #hashQuery = `
        SELECT media_parts.id, media_parts.hash AS hash FROM media_parts
        INNER JOIN media_items ON media_parts.media_item_id=media_items.id
        INNER JOIN metadata_items ON media_items.metadata_item_id=metadata_items.id
        WHERE metadata_items.id=?
        ORDER BY media_parts.id ASC;`;

    /**
     * Create a new ThumbnailManager
     * @param {SqliteDatabase} db The database connection
     * @param {ConsoleLog} log The main application's logging instance.
     * @param {string} metadataPath The path to the root of Plex's data directory
     */
    constructor(db, log, metadataPath) {
        this.#database = db;
        this.#metadataPath = metadataPath;
        this.#log = log;
    }

    /**
     * Determine if an episode has thumbnails generated.
     * @param {number} metadataId The metadata id of the episode to check.
     * @returns {Promise<boolean>} A `Promise` that will resolve to `true` if thumbnails were found, `false`
     * if they weren't found, or `reject`ed if something went wrong.
     */
    async hasThumbnails(metadataId) {
        if (this.#cache[metadataId]) {
            return Promise.resolve(this.#cache[metadataId].hasThumbs);
        }

        return new Promise((resolve, reject) => {
            this.#database.all(ThumbnailManager.#hashQuery, [metadataId], (err, rows) => {
                if (err) {
                    return reject('Unable to retrieve media parts');
                }

                for (const row of rows) {
                    const bifPath = joinPath(this.#metadataPath, 'Media', 'localhost', row.hash[0], row.hash.substring(1) + '.bundle', 'Contents', 'Indexes', 'index-sd.bif');
                    if (existsSync(bifPath)) {
                        this.#cache[metadataId] = new EpisodeCache(true, bifPath);
                        resolve(true);
                        return;
                    }
                }

                this.#cache[metadataId] = new EpisodeCache(false);
                resolve(false);
            });
        });
    }

    /**
     * Retrieve a thumbnail for an episode at a specific timestamp.
     *
     * If we have not yet determined if the episode has an associated thumbnail file,
     * check that before looking for the thumbnail itself.
     * @param {number} metadataId The metadata id for the episode.
     * @param {number} timestamp The timestamp of the thumbnail, in seconds.
     * @returns A `Promise` that will resolve to the thumbnail `Buffer` if the thumbnail
     * retrieval was successful, and `reject`ed if the thumbnail doesn't exist or we were
     * otherwise unable to retrieve it.
     */
    async getThumbnail(metadataId, timestamp) {
        if (!this.#cache[metadataId]) {
            return this.hasThumbnails(metadataId).then(_ => {
                return this.#getThumbnailCore(metadataId, timestamp);
            });
        } else {
            return this.#getThumbnailCore(metadataId, timestamp);
        }
    }

    /**
     * Checks the cache for the requested thumbnail and returns that if available.
     * Otherwise kicks off the process of reading the BIF file.
     *
     * Assumes `hasThumbnails` has been called for the given episode.
     * @param {number} metadataId The metadata id for the episode.
     * @param {number} timestamp The timestamp of the thumbnail, in seconds.
     * @returns A `Promise` that will resolve to the thumbnail `Buffer` if the thumbnail
     * retrieval was successful, and `reject`ed if the thumbnail doesn't exist or we were
     * otherwise unable to retrieve it.
     */
    async #getThumbnailCore(metadataId, timestamp) {
        if (!this.#cache[metadataId] || !this.#cache[metadataId].hasThumbs) {
            return Promise.reject('No thumbnails');
        }

        let thumbCache = this.#cache[metadataId];
        let index;
        if (thumbCache.interval != 0) {
            index = Math.floor(timestamp / thumbCache.interval);
            if (thumbCache.cachedThumbnails[index]) {
                thumbCache.cachedThumbnails[index].rank = ThumbnailManager.#maxCache + 1;
                this.#touchCache();
                return Promise.resolve(thumbCache.cachedThumbnails[index].data);
            }
        }

        return this.#readThumbnail(metadataId, timestamp);
    }

    /**
     * Open the index-sd.bif file associated with the episode and extract the thumbnail
     * closest to the given timestamp (rounded down).
     * @param {number} metadataId The metadata id for the episode.
     * @param {number} timestamp The timestamp of the thumbnail, in seconds.
     * @returns {Promise<Buffer>} A `Promise` that will resolve to the thumbnail `Buffer` if the thumbnail
     * retrieval was successful, and `reject`ed if the thumbnail doesn't exist or we were
     * otherwise unable to retrieve it.
     */
    async #readThumbnail(metadataId, timestamp) {
        let thumbCache = this.#cache[metadataId];
        return new Promise((resolve, reject) => {

            // File layout:
            // Starts with magic 89 42 49 46 0D 0A 1A 0A (0x89 BIF \r\n\sub\n)
            // 32(?)-bit integer at offset 0xC indicating the number of thumbnails in the file
            // Index table starts at 0x40, with 8-byte records:
            //   * A 32-bit little-endian integer timestamp (in seconds) -> 02 00 00 00 -> 2 seconds
            //   * A 32-bit little-endian integer offset into the file indicating the start of the thumbnail.
            readFile(thumbCache.bifPath, (err, data) => {
                if (err) {
                    reject('Failed to read thumbnail file');
                    return;
                }

                const thumbnailCountOffset = 0xC;
                const indexTableStart = 0x40;
                const recordSize = 0x8;
                const timestampSize = 0x4;
                const getOffset = (index) => data.readInt32LE(indexTableStart + (index * recordSize) + timestampSize);
                const getTimestamp = (index) => data.readInt32LE(indexTableStart + (index * recordSize));

                if (thumbCache.interval == 0) {
                    const verify = getTimestamp(0);
                    if (verify != 0) {
                        reject('Unexpected thumbnail file contents');
                        return;
                    }

                    thumbCache.interval = getTimestamp(1);
                }

                let index = Math.floor(timestamp / thumbCache.interval);

                // Last index points to the end of the file, so the real max is the
                // number of indexes minus 1.
                const maxIndex = data.readInt32LE(thumbnailCountOffset) - 1;
                if (index > maxIndex) {
                    this.#log.warn('Received thumbnail request beyond max timestamp. Retrieving last thumbnail instead.');
                    index = maxIndex;
                }

                const thumbStart = getOffset(index);
                const thumbEnd = index == maxIndex ? data.length : getOffset(index + 1);
                const thumbBuf = Buffer.alloc(thumbEnd - thumbStart);
                data.copy(thumbBuf, 0, thumbStart, thumbEnd);
                thumbCache.cachedThumbnails[index] = new CachedThumbnail(thumbBuf, ThumbnailManager.#maxCache + 1);
                this.#touchCache();
                resolve(thumbBuf);
            });
        });
    }

    /** Updates our LRU cache, removing items that haven't been retrieved in the last `#maxCache` requests. */
    #touchCache() {
        for (const cacheItem of Object.values(this.#cache)) {
            for (const index of Object.keys(cacheItem.cachedThumbnails)) {
                if (--cacheItem.cachedThumbnails[index].rank == 0) {
                    delete cacheItem.cachedThumbnails[index];
                }
            }
        }
    }
}

/** @typedef {{[timestamp: number]: CachedThumbnail}} ThumbnailMap */

/** Holds information about the index-sd.bif file for an episode, including any cached thumbnails. */
class EpisodeCache {
    /** Whether this episode has thumbnails available.
     * @type {boolean} */
    hasThumbs;

    /** The path to `index-sd.bif`, if `hasThumbs` is `true`.
     * @type {string} */
    bifPath;

    /** The cache of current thumbnails.
     * @type {ThumbnailMap} */
    cachedThumbnails = {};

    /** The number of seconds between thumbnails in `index-sd.bif`
     * @type {number} */
    interval = 0;
    /**
     * Construct an EpisodeCache.
     * @param {boolean} hasThumbs `true` if the episode has thumbnails, false otherwise.
     * @param {string} [bifPath=''] The path to the index-sd.bif file, if `hasThumbs` is true. */
    constructor(hasThumbs, bifPath='') {
        this.hasThumbs = hasThumbs;
        this.bifPath = bifPath;
    }
}

/** A cached thumbnail, along with its rank (to be used by cache pruning). */
class CachedThumbnail {
    /** The raw byte buffer of the thumbnail.
     * @type {Buffer} */
    data;

    /** The positing of the thumbnail in the LRU cache.
     * @type {number} */
    rank;

    /**
     * Construct a CachedThumbnail
     * @param {Buffer} buffer The raw byte buffer of the thumbnail
     * @param {number} rank The position of the thumbnail in the LRU cache. */
    constructor(buffer, rank) {
        this.data = buffer;
        this.rank = rank;
    }
}

export default ThumbnailManager;
