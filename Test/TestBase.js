// External dependencies
import fetch from 'node-fetch';
import { existsSync, writeFileSync, unlinkSync, mkdirSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

// Common-JS dependencies
import CreateDatabase from "../Server/CreateDatabase.cjs";

// Client/Server shared dependencies
import { ConsoleLog, Log } from "../Shared/ConsoleLog.js";

// Server/test dependencies/typedefs
import TestHelpers from "./TestHelpers.js";
import { run as mainRun, getState } from "../Server/PlexIntroEditor.js";
import { TestLog } from './TestRunner.js';
import DatabaseWrapper from '../Server/DatabaseWrapper.js';
import ServerState from '../Server/ServerState.js';

/**
 * Base class for integration tests, containing common test configuration logic.
 */
class TestBase {
    /** @type {method[]} */
    testMethods = [];

    static root = join(dirname(dirname(fileURLToPath(import.meta.url))), 'Test');
    static testConfig = join(TestBase.root, 'testConfig.json');
    static testDbPath = join(TestBase.root, 'plexDbTest.db');
    static backupDbPath = join(TestBase.root, 'Backup', 'markerActions.db');

    /** @type {DatabaseWrapper} */
    testDb = null;
    /** @type {DatabaseWrapper} */
    backupDb = null;

    constructor() {
        TestLog.tmi('TestBase Constructor');
    }

    /** The name of this test class. Should be overridden by implementing classes. */
    className() { return 'TestBase'; }

    /**
     * Base method to setup the test config. Implementing classes can override this
     * to provide custom settings. */
    setupConfig() { this.createConfig({}); }

    /**
     * Static helper method that attempts to delete the autogenerated test database/config */
    static Cleanup() {
        if (existsSync(TestBase.testDbPath)) {
            TestLog.tmi(`TestBase::Cleanup - Deleting old database`);
            unlinkSync(TestBase.testDbPath);
        }

        if (existsSync(TestBase.testConfig)) {
            TestLog.tmi(`TestBase::Cleanup - Deleting old config`)
            unlinkSync(TestBase.testConfig);
        }
    }

    /**
     * General purpose method that will be called before a test is executed. */
    testMethodSetup() {}

    /**
     * General purpose method that will be called after a test is executed. */
    testMethodTeardown() {
        // Tests that expect to fail disable Error logging in the main Log (see `expectFailure`). Rest it to Warn.
        Log.setLevel(ConsoleLog.Level.Warn);
    }

    /**
     * Sets the application log level to suppress everything but critical messages
     * because we expect operations to fail. */
    expectFailure() {
        Log.setLevel(ConsoleLog.Level.Critical);
    }

    /**
     * Initiate the run for this test class, setting up the database and config file before
     * running through the test methods.
     * @param {string?} methodName The specific test method to run, if any. */
    async runTests(methodName) {
        TestBase.Cleanup();
        let methodFn = null;
        if (methodName) {
            const availableMethods = {};
            this.testMethods.map(fn => { availableMethods[fn.name] = fn });
            if (!availableMethods[methodName]) {
                throw new Error(`Test method ${methodName} not found. Make sure the test exists, and casing is correct.`);
            }

            methodFn = availableMethods[methodName];
        }

        try {
            this.testDb = new DatabaseWrapper(await CreateDatabase(TestBase.testDbPath, true /*allowCreate*/));
        } catch (err) {
            TestLog.error(err, `Failed to create test database, cannot run ${this.className()}!`);
            throw err;
        }

        await this.connectToBackupDatabase();
        await this.setupPlexDbTestTables();

        this.setupConfig();
        await this.startService();
        if (methodFn) {
            return this.runSingle(methodFn);
        }

        return this.runAll();
    }

    /**
     * Writes the test configuration to disk.
     * @param {{}} overrides Dictionary of custom configuration values to set, if any. */
    createConfig(overrides) {
        const td = (field, value, force=false) => { if (!overrides.hasOwnProperty(field) || force) { overrides[field] = value; } };
        const tf = (feature, value) => { if (!overrides.features) { overrides.features = {}; } if (!overrides.features.hasOwnProperty(feature)) { overrides.features[feature] = value; }};

        // Test defaults
        td('host', 'localhost', true);
        td('port', 3233, true);
        td('database', TestBase.testDbPath, true);
        td('logLevel', 'DarkWarn');

        // Good testing of preview thumbnails would require actual bif files and proper test db
        // entries that I don't want to deal with right now.
        tf('previewThumbnails', false);
        tf('autoOpen', false);

        // TODO: Actually test this
        tf('backupActions', true);

        writeFileSync(TestBase.testConfig, JSON.stringify(overrides));
    }

    /**
     * Starts the Plex Intro Editor. Expects to have been run via launch.json's "Run Tests"
     * configuration, which will pass in the right command line arguments to mainRun. */
    async startService() {
        if (getState() == ServerState.FirstBoot) {
            return mainRun();
        }

        return this.resume();
    }

    /**
     * Run all available test methods for this class. */
    async runAll() {
        TestLog.info(`Running tests for ${this.className()}`);
        let successCount = 0;
        let failureCount = 0;
        for (const method of this.testMethods) {
            const success = await this.#runSingleInternal(method);
            success ? ++successCount : ++failureCount;
        }

        TestLog.info(`Ran ${this.testMethods.length} tests`);
        TestLog.info(`\tPASSED: ${successCount}`);
        TestLog.info(`\tFAILED: ${failureCount}`);
        if (failureCount != 0) {
            TestLog.error(`FAILED! One or more tests in ${this.className()} did not pass!`);
        }

        const result = { success : successCount, fail : failureCount };

        await this.testDb?.close();
        await this.backupDb?.close();
        return Promise.resolve(result);
    }

    async runSingle(testFn) {
        TestLog.info(`Running ${this.className()}::${testFn.name}`);
        const success = await this.#runSingleInternal(testFn);
        await this.testDb?.close();
        await this.backupDb?.close();
        return Promise.resolve({ success : success ? 1 : 0, fail : success ? 0 : 1 });
    }

    async #runSingleInternal(testMethod) {
        await this.resetState();
        await this.resume();
        this.testMethodSetup();
        let success = true;
        let response = '';
        try {
            await testMethod.bind(this)();
        } catch (ex) {
            success = false;
            response = ex.message;
        }

        this.testMethodTeardown();

        TestLog.verbose(`\t[${testMethod.name}]: ${success ? 'PASSED' : 'FAILED'}`);
        if (!success) {
            TestLog.verbose(`\t\t${response}`);
        }

        await this.suspend();
        return success;
    }

    /**
     * Suspend the test server, which will disconnect it from the test config
     * and database, allowing us to reset the server state between tests. */
    async suspend() {
        if (getState() != ServerState.Running) {
            return Promise.resolve();
        }

        return new Promise(function (resolve, _) {
            this.send('suspend').then(_ => {
                TestLog.tmi('Detached from test server');
                resolve();
            }).catch(err => {
                TestLog.error(err, 'Failed to shut down test server cleanly, force stopping tests');
                process.exit(1);
            });
        }.bind(this));
    }

    /**
     * Resumes the test server after being suspended for cleanup. */
    async resume() {
        if (getState() != ServerState.Suspended) {
            return Promise.resolve();
        }

        await this.send('resume');
        Log.tmi('Resuming server');
        return Promise.resolve();
    }

    /**
     * Send a request to the test server.
     * @param {string} endpoint The command to run
     * @param {*} params Dictionary of query parameters to pass into the test server.
     * @param {boolean} raw Whether to return the immediate fetch result, not the parsed JSON data. */
    async send(endpoint, params={}, raw=false) {
        return this.#fetchInternal(endpoint, params, 'POST', { accept : 'application/json' } , raw);
    }

    /**
     * Sends a GET request to the test server.
     * @param {string} endpoint The file to retrieve
     * @param {*} params Dictionary of query parameters to pass into the test server.
     * @returns {Promise<Response>} */
    async get(endpoint, params={}) {
        return this.#fetchInternal(endpoint, params, 'GET', {}, true);
    }

    /**
     * Internal fetch handler
     * @param {string} endpoint
     * @param {*} params
     * @param {string} method POST or GET
     * @param {*} headers Any additional headers to add to the request
     * @param {boolean} raw */
    async #fetchInternal(endpoint, params, method, headers, raw) {
        if (getState() == ServerState.FirstBoot || getState() == ServerState.ShuttingDown) {
            TestLog.warn('TestHarness: Attempting to send a request to the test server when it isn\'t running!');
            return;
        }

        let url = new URL(`http://localhost:3233/${endpoint}`);
        for (const [key, value] of Object.entries(params)) {
            url.searchParams.append(key, value);
        }

        if (raw) {
            return fetch(url, { method : method, headers : headers });
        } else {
            TestHelpers.verify(method == 'POST', `We shouldn't be making non-raw GET requests`);
            return fetch(url, { method : method, headers : headers }).then(r => r.json());
        }
    }

    /**
     * Map of default metadata items to their metadata/marker ids. */
    static DefaultMetadata = {
        Show1 : { Id : 1,
            Season1 : { Id : 2,
                Episode1 : { Id : 3, },
                Episode2 : { Id : 4,
                    Marker1 : { Id : 1,
                        Start : 15000,
                        End : 45000
                    },
                },
                Episode3 : { Id : 5, },
            },
            Season2 : { Id : 6,
                Episode1 : { Id : 7, },
            }
        },
        Show2 : { Id : 8,
            Season1 : { Id : 9,
                Episode1 : { Id : 10, },
            },
        },
    }

    /**
     * Create the minimal recreation of the Plex database and enter some default metadata and marker items. */
    async setupPlexDbTestTables() {
        if (!this.testDb) {
            TestLog.error('Cannot add test marker, database is not initialized!');
            return;
        }

        const tables = TestHelpers.getCreateTables();

        // Create the intro marker tag.
        const introInsert = `INSERT INTO tags (tag_type) VALUES (12);`;

        // Create a single TV library, and a movie library
        const sectionInsert = `
        INSERT INTO library_sections (library_id, name, section_type, uuid)
        VALUES                       (1,          "TV", 2,            "94319c6e-16c0-11ed-861d-0242ac120002"),
                                     (2,           "M", 1,            "dbdf1795-0f3c-4a9b-956b-6f10edb6eccc");`;

        // TODO: Have a "base" set of shows/seasons/episodes that cover many scenarios, with the option to override
        //       what's added to accommodate any scenario. Also have a map that indicates what's available
        // Type - 2=show, 3=season, 4=episode
        // Index - show=1, everything else = season/episode index
        // inserting id isn't necessary, just helpful for tracking
        const metadataInsert = `
        INSERT INTO metadata_items (id, library_section_id, metadata_type, parent_id, title,     \`index\`)
        VALUES                     (1,  1,                  2,             NULL,      "Show1",    1),
                                   (2,  1,                  3,             1,         "Season1",  1),
                                   (3,  1,                  4,             2,         "Episode1", 1),
                                   (4,  1,                  4,             2,         "Episode2", 2),
                                   (5,  1,                  4,             2,         "Episode3", 3),
                                   (6,  1,                  3,             1,         "Season2",  2),
                                   (7,  1,                  4,             6,         "Episode1", 1),
                                   (8,  1,                  2,             NULL,      "Show2",    1),
                                   (9,  1,                  3,             8,         "Season1",  1),
                                   (10, 1,                  4,             9,         "Episode1", 1),

                                   (100,2,                  1,             NULL,      "Movie1",   1);`;

        // Need existing media, but only the metadata_item_id and duration field (for now)
        const mediaInsert = `
        INSERT INTO media_items (metadata_item_id, duration)
        VALUES                  (3,                10000),
                                (4,                10000),
                                (5,                10000),
                                (7,                10000),
                                (10,               10000);`;

        return this.testDb.exec(tables + introInsert + sectionInsert + metadataInsert + mediaInsert + this.defaultMarkers());
    }

    /**
     * Connect to (and create if necessary) a marker backup database for tests. */
    async connectToBackupDatabase() {
        const testBackupPath = join(TestBase.root, 'Backup');
        if (!existsSync(testBackupPath)) {
            TestLog.verbose('Creating test backup directory');
            mkdirSync(testBackupPath);
        }

        this.backupDb = new DatabaseWrapper(await CreateDatabase(TestBase.backupDbPath, true /*allowCreate*/));
    }

    /** @returns The INSERT statements that will add the default markers to the test database. */
    defaultMarkers() {
        const episode = TestBase.DefaultMetadata.Show1.Season1.Episode2;
        const dbMarkerInsert = (metadataId, index, start, end) => `
            INSERT INTO taggings
                (metadata_item_id, tag_id, "index", text, time_offset, end_time_offset, created_at, extra_data)
            VALUES
                (${metadataId}, 1, ${index}, "intro", ${start}, ${end}, CURRENT_TIMESTAMP, "pv%3Aversion=5");`
        return dbMarkerInsert(episode.Id, 0, episode.Marker1.Start, episode.Marker1.End);
    }

    /**
     * Add a marker to the given episode via the 'add' endpoint.
     * @param {number} episodeId The episode's metadata id
     * @param {number} startMs
     * @param {number} endMs
     * @param {boolean} raw Whether the Response should be returned instead of the json response. */
    async addMarker(episodeId, startMs, endMs, raw=false) {
        return this.send('add', {
            metadataId : episodeId,
            start : startMs,
            end : endMs
        }, raw);
    }

    /**
     * Edit a marker with the given id via the 'edit' endpoint.
     * @param {number} markerId
     * @param {number} startMs
     * @param {number} endMs
     * @param {boolean} raw Whether the Response should be returned instead of the json response. */
    async editMarker(markerId, startMs, endMs, raw=false) {
        return this.send('edit', {
            id : markerId,
            start : startMs,
            end : endMs,
            userCreated : 0
        }, raw);
    }

    /**
     * Clear out the test databases and re-enter the default data. */
    async resetState() {
        await this.testDb?.exec(`
            DELETE FROM taggings;
            VACUUM;
            UPDATE sqlite_sequence SET seq=0 WHERE name="taggings";
            ${this.defaultMarkers()}`);
        await this.backupDb?.exec(`
            DELETE FROM actions;
            VACUUM;
            UPDATE sqlite_sequence SET seq=0 WHERE name="actions";`);
        return Promise.resolve();
    }
}

export default TestBase;
